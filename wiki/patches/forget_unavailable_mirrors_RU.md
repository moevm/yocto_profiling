# forget_unavailable_mirrors.patch

Попытка реализовать "забывание" недоступных серверов с кэшем при получении ошибки недоступности (5** код)

> [!IMPORTANT]
> Описание для коммита e4a79c9a60893e2ec36ea4634ee52a0704185a60 

### Основная проблема
Основная проблема в том, что в bitbake такой функциональности нет. Вся логика обработки построена на том, что мы либо находим файл и возвращаем true, либо не находим и возвращаем false.

Интеграция этой логики -- сложная и большая задача, потому что метод опроса зависит от протокола взаимодействия, поддерживаемого в bitbake, т.е. для каждого протокола нужно реализовывать логику отслеживания ошибок недоступности сервера, возвращать специфическое значение наверх по стеку вызовов, чтобы как-то изменить логику будующих опросов. Задача осложняется архитектурой системы: во время скачивания, начиная с некоторого момента, отсутствует доступ к data классу (есть доступ к его копии), что не позволяет из метода, в котором получается ошибка недоступности, убрать все упоминания недоступного сервера. 

### Решение  
Подыматься с помощью raise на уровень, где абстрактно описана логика опроса зеркал и, в случае получения ошибки, перехватывать ее и менять будущую логику обработки. 

На данном этапе реализован этот "подъем" к месту, где запускается опрос серверов -- метод `try_mirrors`.


### Текущая проблема 
Текущая проблема -- реорганизация цикла опроса зеркал. 
В текущей версии `try_mirrors` сначала получается список интересущих нас адресов:
```
uris, uds = build_mirroruris(origud, mirrors, ld)
```

А потом запускается большой цикл опроса:
```
for index, uri in enumerate(uris):
```

#### Проблема реорганизации 
1. Если просто обновить список зеркал, без изменения цикла и `uris`, то эффекта не будет, цикл будет идти по всем заранее составленным ссылкам
2. Если оборвать цикл, то теряется текущий прогресс (опросили 3 тысячи задач, получили ошибку, прервали цикл, пересчитали `uris`, опять запустили цикл и повторно опросили 3 тысячи опрошенных пакетов -- это плохо)
3. Реаорганизация с сохранением текущего прогресса с динамическим пересчетом `uris`. Возможно, имеет смысл переписать на while.


### Эксперименты по количеству запросов
Если сервер недоступен (приблизительно столько же запросов к рабочему серверу), то проходит в среднем:
- 1 запрос к каждому пакету (для файла `.siginfo`)
- 2 запрос к каждому пакету (для файла не `.siginfo`)

Итого каждый нерабочий сервер создает нагрузку 3*количество задач. Для core-image-minimal около 6.8 тысяч запросов получается по итогу. 
